# -*- coding: utf-8 -*-
"""Music Recommendation System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XZSIK9cDOfkW94hSX1M-02ubM9BRW5HD

**Import Modules**
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from google.colab import drive
drive.mount('/content/drive')

"""**Read CSV File**"""

df = pd.read_csv('/content/Hindi Songs.csv')

print(df.to_string())

"""**Checking Dataframe Information**"""

print(df.info())

"""**Names of the Columns in the Dataset**"""

print(df.columns)

"""**Total Available Songs in the Dataset**"""

print("Available song titles:")
for song in df['song_name'].unique():
    print(f"- {song}")

"""**Descriptive Statistics of the DataFrame**"""

import pandas as pd
import os

file_path = '/content/Hindi Songs.csv'

# Ensure df is defined, in case the kernel was restarted or the defining cell was not run.
if os.path.exists(file_path):
    df = pd.read_csv(file_path)
    print(df.describe())
else:
    print(f"‚ùå Error: The file '{file_path}' was not found. Please upload the 'Hindi Songs.csv' file to your Colab environment.")

"""**Displaying the First Few Rows of the Dataframe**"""

print(df.head())

"""**Songs Released in the Year**"""

print("üìã Available columns:")
print(df.columns.tolist())

import pandas as pd
import os

file_path = '/content/Hindi Songs.csv'

# Check if the file exists before loading
if os.path.exists(file_path):
    df = pd.read_csv(file_path)
    year = (1971, 1962)

    songs_by_year = df[df['released year'].isin(year)]

    print(f"üéµ Songs released in {year}:")
    print(songs_by_year[['song_name', 'singer']])
else:
    print(f"‚ùå Error: The file '{file_path}' was not found. Please upload the 'Hindi Songs.csv' file to your Colab environment.")

df.columns = df.columns.str.strip().str.lower()
print(df.columns.tolist())

import pandas as pd
import os

file_path = '/content/Hindi Songs.csv' # Corrected file path

# Check if the file exists before loading
if os.path.exists(file_path):
    df = pd.read_csv(file_path)

    # Display first few rows to check column names
    print(df.head())

    # ‚úÖ Specify the year(s) you want to filter
    year = [1971]   # you can also use multiple years like [1971, 1980, 1995]

    # ‚úÖ Filter songs by year
    songs_by_year = df[df['released year'].isin(year)]

    # ‚úÖ Display the filtered songs
    print("\nSongs released in", year, ":")
    print(songs_by_year[['song_name', 'singer', 'released year']])
else:
    print(f"‚ùå Error: The file '{file_path}' was not found. Please upload the 'Hindi Songs.csv' file to your Colab environment.")

"""### **Checking Information of the 'song_name' Column**

"""

import pandas as pd
import os

file_path = '/content/Hindi Songs.csv'

# Check if the file exists before loading
if os.path.exists(file_path):
    df = pd.read_csv(file_path)
    # Check if 'song_name' column exists after loading the correct DataFrame
    if 'song_name' in df.columns:
        print(df['song_name'].info())
    else:
        print("‚ùå Error: 'song_name' column not found in 'Hindi Songs.csv'. Please check the dataset columns.")
else:
    print(f"‚ùå Error: The file '{file_path}' was not found. Please upload the 'Hindi Songs.csv' file to your Colab environment.")

"""**Total Availability of Songs**"""

import pandas as pd
import os

file_path = '/content/Hindi Songs.csv'

# Check if the file exists
if os.path.exists(file_path):

    try:
        # Load CSV file
        df_songs = pd.read_csv(file_path)

        # Check if 'song_name' column exists
        if 'song_name' in df_songs.columns:
            print("Available song titles:")
            for song in df_songs['song_name'].unique():
                print(f"- {song}")
        else:
            print("‚ùå Error: 'song_name' column is missing in the CSV file.")

    except Exception as e:
        print(f"‚ùå Error while reading the file: {e}")

else:
    print(f"‚ùå Error: File not found at: {file_path}. Please upload 'Hindi Songs.csv' to Colab.")

"""**Data Cleaning**"""

import pandas as pd
import os

# Ensure df is the Hindi Songs dataset for cleaning
file_path = '/content/Hindi Songs.csv'
if os.path.exists(file_path):
    df = pd.read_csv(file_path)
else:
    print(f"‚ùå Error: The file '{file_path}' was not found. Cannot perform cleaning.")
    # Exit or handle the error appropriately if the file is essential
    raise FileNotFoundError(f"File not found: {file_path}")

# Standardize column names to lowercase for consistency
df.columns = df.columns.str.strip().str.lower()

df.drop_duplicates(inplace=True)
df.dropna(subset=['song_name', 'singer'], inplace=True)

print("Cleaned DataFrame shape:")
print(df.shape)
print("Cleaned DataFrame head:")
display(df.head())

"""## **Checking Missing Values in the Dataset**"""

import pandas as pd
import os

file_path = '/content/Hindi Songs.csv'

# Check if the file exists before loading
if os.path.exists(file_path):
    df = pd.read_csv(file_path)
    if 'song_name' in df.columns and 'singer' in df.columns:
        print(df[['song_name', 'singer']].isnull().sum())
    else:
        print(f"‚ùå Error: The loaded CSV file '{file_path}' does not contain 'song_name' or 'singer' columns. Please check the file content.")
else:
    print(f"‚ùå Error: The file '{file_path}' was not found. Please upload the 'Hindi Songs.csv' file to your Colab environment.")

"""**Checking Missing Values for all Columns in the Dataset**"""

print(df.isnull().sum())

"""**Total count of missing values in the Dataset**



"""

df.isnull().sum().sum()

"""**Number of Row and Columns in the Dataset**"""

df.shape

"""**Dataset Cleaning**"""

df.to_csv("Cleaned_Hindi_Songs.csv", index=False)
print("‚úÖ Cleaned dataset saved successfully!")

"""**Load and Validate the Social Media Sentiment Analysis Dataset**"""

import pandas as pd
import os

file_path = '/content/Social Media Sentimental Analysis.csv'

if os.path.exists(file_path):
    print(f"‚úÖ '{file_path}' found. Attempting to load...")
    try:
        df_check = pd.read_csv(file_path)
        print("‚úÖ Successfully loaded 'Hindi Songs.csv'. First 5 rows:")
        display(df_check.head())
    except Exception as e:
        print(f"‚ùå Error loading '{file_path}': {e}")
else:
    print(f"‚ùå '{file_path}' not found. Please upload the file.")

"""## **TF-IDF matrix from the text data in the 'song_name' and 'singer' columns.**"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Combine relevant text columns into a single string
df['text_features'] = df['song_name'] + ' ' + df['singer']

# Initialize TfidfVectorizer
tfidf = TfidfVectorizer(stop_words='english')

# Fit and transform the text features to create the TF-IDF matrix
tfidf_matrix = tfidf.fit_transform(df['text_features'])

print("Shape of TF-IDF matrix:", tfidf_matrix.shape)

"""**This section gives top 5 similar songs based on TF-IDF text similarity**"""

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Step 1: Load dataset
df = pd.read_csv('/content/Hindi Songs.csv')

# Step 2: Clean and combine text columns safely
df['song_name'] = df['song_name'].fillna('').astype(str)
df['singer'] = df['singer'].fillna('').astype(str)
df['text_features'] = (df['song_name'] + ' ' + df['singer']).str.strip()

# Step 3: Create TF-IDF matrix
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['text_features'])

# Step 4: Compute cosine similarity matrix
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Step 5: Function to recommend top 5 similar songs
def recommend(song_name, cosine_sim=cosine_sim):
    try:
        idx = df[df['song_name'] == song_name].index[0]
    except IndexError:
        print("‚ö†Ô∏è Song not found in dataset.")
        return None, None

    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:6]  # skip the song itself

    song_indices = [i[0] for i in sim_scores]
    scores = [i[1] for i in sim_scores]
    recommended_songs = df['song_name'].iloc[song_indices].to_dict()

    return recommended_songs, scores

# Example usage
song_name = "Om Shanti Om (Meri Umar Ke Naujawano)"
recommended_songs, scores = recommend(song_name)

print(f"üéµ Top 5 songs similar to '{song_name}':\n")
if recommended_songs:
    for (original_index, song), score in zip(recommended_songs.items(), scores):
        print(f"- {song} (Score: {score:.2f})")

"""**TF-IDF Vectorization and Cosine Similarity Calculation for Songs**"""

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Combine relevant text columns into a single string
df['text_features'] = df['song_name'] + ' ' + df['singer']

# Initialize TfidfVectorizer
tfidf = TfidfVectorizer(stop_words='english')

# Fit and transform the text features to create the TF-IDF matrix
tfidf_matrix = tfidf.fit_transform(df['text_features'])

print("Shape of TF-IDF matrix:", tfidf_matrix.shape)

# Calculate cosine similarity between all songs
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

print("‚úÖ Cosine similarity matrix created!")
print("Shape of cosine similarity matrix:", cosine_sim.shape)

"""## **Calculating and Displaying the Cosine Similarity Matrix for All Songs**


"""

from sklearn.metrics.pairwise import cosine_similarity

# Calculate cosine similarity between all songs
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

print("‚úÖ Cosine similarity matrix created!")
print("Shape of cosine similarity matrix:", cosine_sim.shape)

print(cosine_sim[:10, :10])

"""**Create list of similarity scores for each song**"""

sim_scores_list = []
for idx in range(len(df)):
    sim_scores = list(enumerate(cosine_sim[idx]))  # (song_index, similarity_score)
    sim_scores_list.append(sim_scores)

# ‚úÖ Example: print similarity scores for the first song
print("Similarity scores for:", df['song_name'][0])
print(sim_scores_list[0][:5])  # show top 5 entries

"""## **Top 10 similarity scores for first song**"""

print(sim_scores_list[1][:10])

top_similar_songs = []

for idx in range(len(df)):
    # Get similarity scores for the current song
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Sort the songs by similarity score (highest first)
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get top 5 most similar songs (excluding the same song itself)
    top_10 = sim_scores[1:10]

    top_similar_songs.append(top_10)

top_similar_songs = [
   [(1, 0.93), (2, 0.87), (5, 0.76), (7, 0.73), (3, 0.70),(4, 0.60),(8,0.72),(9,0.65),(10,0.78),(4,0.98)],
   [(0, 0.93), (2, 0.81), (4, 0.79), (8, 0.74), (5, 0.70),(3,0.72),(6,0.80),(7,0.82),(9,0.68),(10,0.55)],
   ...
]

print(top_similar_songs)

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import os

file_path = '/content/Hindi Songs.csv'

if not os.path.exists(file_path):
    print(f"Error: The file '{file_path}' was not found. Please ensure it is uploaded or available.")
else:
    # Ensure df is defined by re-loading the CSV
    df = pd.read_csv(file_path)

    # Handle NaN values and ensure columns are string type before creating 'text_features'
    df['song_name'] = df['song_name'].fillna('').astype(str)
    df['singer'] = df['singer'].fillna('').astype(str)
    df['text_features'] = (df['song_name'] + ' ' + df['singer']).str.strip()

    # Re-calculate TF-IDF matrix
    tfidf = TfidfVectorizer(stop_words='english')
    tfidf_matrix = tfidf.fit_transform(df['text_features'])

    # Re-calculate cosine similarity
    cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

    # Re-create top_similar_songs list
    top_similar_songs = []
    for idx in range(len(df)):
        sim_scores = list(enumerate(cosine_sim[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
        top_10 = sim_scores[1:10]
        top_similar_songs.append(top_10)

    song_index = 0  # example: first song
    print("üéµ Song:", df.iloc[song_index]['song_name'], "by", df.iloc[song_index]['singer'])
    print("\nTop 10 similar songs:")

    for i, score in top_similar_songs[song_index]:
        print(f"- {df.iloc[i]['song_name']} by {df.iloc[i]['singer']} (Score: {score:.2f})")

"""**Barplot For Top 10 artists by Number of Songs**"""

import matplotlib.pyplot as plt
import seaborn as sns

# Enable better plot visuals
plt.style.use('seaborn-v0_8-darkgrid')

top_artists = df['singer'].value_counts().head(10)

plt.figure(figsize=(10,6))
sns.barplot(x=top_artists.values, y=top_artists.index, palette='viridis')
plt.title('üé§ Top 10 Artists by Number of Songs', fontsize=14)
plt.xlabel('Number of Songs')
plt.ylabel('Artist')
plt.show()

"""## **Histogram ‚Äî Distribution of Song Release Years**"""

# Convert release year to numeric year
df['year'] = pd.to_numeric(df['released year'], errors='coerce')

plt.figure(figsize=(10,6))
plt.hist(df['year'].dropna(), bins=20, color='skyblue', edgecolor='black')
plt.title('üìÖ Distribution of Song Release Years', fontsize=14)
plt.xlabel('Year')
plt.ylabel('Number of Songs')
plt.show()

"""**Boxplot for Song Liveness Distribution**"""

plt.figure(figsize=(8,6))
sns.boxplot(y=df['liveness'], color='orange')
plt.title('üìè Distribution of Song Liveness')
plt.ylabel('Liveness Score')
plt.show()

"""# **Boxplot for Song Popularity Distribution**"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(8,6))
sns.boxplot(y=df['popularity'], color='Green')
plt.title('üéµ Distribution of Song Popularity')
plt.ylabel('Popularity Score')
plt.show()

"""**Multiple Boxplot For Comparison**"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10,6))
sns.boxplot(data=df[['danceability', 'energy', 'liveness', 'acousticness', 'popularity']])
plt.title('üéß Distribution of Audio Features')
plt.ylabel('Feature Values')
plt.show()

"""**Distribution of Songs by Name**"""

import matplotlib.pyplot as plt

# Count of songs per name
song_name_counts = df['song_name'].value_counts()  # Series: index=song_name, values=count

# Plot pie chart
plt.figure(figsize=(8,8))
plt.pie(song_name_counts, labels=song_name_counts.index, autopct='%1.1f%%', startangle=140, colors=plt.cm.tab20.colors)
plt.title('Distribution of Songs by Name')
plt.show()

"""**Feature Correlation Heatmap of Numeric Columns**"""

numeric_df = df.select_dtypes(include='number')

plt.figure(figsize=(8,6))
sns.heatmap(numeric_df.corr(), annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Feature Correlation Heatmap')
plt.show()

"""## **Popularity Distribution of Songs by Release Year**"""

# Convert release year to numeric year
df['year'] = pd.to_numeric(df['released year'], errors='coerce')

import pandas as pd

# ‚úÖ Load your dataset
file_path = 'Hindi Songs.csv'   # replace with your actual CSV file path
df = pd.read_csv(file_path)

# ‚úÖ Show the data before conversion
print("Before conversion:")
print(df[['song_name', 'released year']].head())

# ‚úÖ Convert 'released year' to numeric and store it in a new column 'year'
# 'errors="coerce"' converts invalid or missing values to NaN
df['year'] = pd.to_numeric(df['released year'], errors='coerce')

# ‚úÖ Optional: drop rows where year could not be converted (NaN values)
df = df.dropna(subset=['year'])

# ‚úÖ Convert float years to integer type (optional)
df['year'] = df['year'].astype(int)

# ‚úÖ Display the result
print("\nAfter conversion:")
print(df[['song_name', 'released year', 'year']].head())

sns.boxplot(x='year', y='popularity', data=df)
plt.title("Popularity Distribution by Year")
plt.show()

"""**Applying Recommender Function**"""

def recommender(song_name, cosine_sim):
    # Get the index of the song
    try:
        idx = df[df['song_name'] == song_name].index[0]
    except IndexError:
        print("Song not found in dataset.")
        return None

    # Get similarity scores for this song and sort them
    distance = sorted(list(enumerate(cosine_sim[idx])), reverse=True, key=lambda x: x[1])

    # Get top 4 similar songs (excluding the input song itself)
    recommended_songs = []
    for s_id in distance[1:5]:
        recommended_songs.append(df.iloc[s_id[0]]['song_name'])

    return recommended_songs

recommended_songs = recommender('Om Shanti Om (Meri Umar Ke Naujawano)', cosine_sim)

if recommended_songs:
    print(f"Top recommended songs similar to 'Om Shanti Om (Meri Umar Ke Naujawano)':")
    for song in recommended_songs:
        print(f"- {song}")

"""**Popularity Recommendation Engine**"""

class Recommenders:
    def __init__(self):
        self.df = None
        self.item_id = None
        self.user_id = None
        self.popularity_recommendations = None

    @classmethod
    def popularity_recommender_py(cls):
        # Placeholder for your popularity recommender implementation
        print("Placeholder for popularity recommender logic.")
        # You will need to replace this with your actual recommendation logic
        return cls() # Return an instance of the class

    def create(self, df, user_id, item_id):
        """
        Creates the popularity recommender model.

        Args:
            df (pandas.DataFrame): The training data.
            user_id (str): The column name for user IDs.
            item_id (str): The column name for item IDs (songs).
        """
        self.df = df
        self.user_id = user_id
        self.item_id = item_id
        print("Popularity recommender model created.")

        # Calculate popularity and store recommendations (placeholder)
        # You'll replace this with actual popularity calculation
        self.popularity_recommendations = df.sort_values(by='Stream', ascending=False).head(10)


    def recommend(self, user_id):
        """
        Generates popularity recommendations for a given user.

        Args:
            user_id: The user ID (not used in popularity recommendation but kept for consistency).

        Returns:
            pandas.DataFrame: DataFrame containing recommended items.
        """
        print("Generating popularity recommendations...")
        # Return the pre-calculated popularity recommendations
        return self.popularity_recommendations

pr = Recommenders()

"""## **Get popularity recommendations** **and display the recommendations**"""

import pandas as pd
import os

# Class definition for Recommenders
class Recommenders:
    def __init__(self):
        self.df = None
        self.item_id = None
        self.user_id = None
        self.popularity_recommendations = None

    @classmethod
    def popularity_recommender_py(cls):
        print("Placeholder for popularity recommender logic.")
        return cls()

    def create(self, df, user_id, item_id):
        self.df = df
        self.user_id = user_id
        self.item_id = item_id
        print("Popularity recommender model created.")
        if 'Stream' in df.columns:
            self.popularity_recommendations = df.sort_values(by='Stream', ascending=False).head(10)
        else:
            print("Warning: 'Stream' column not found for popularity calculation. Recommendations will be empty.")
            self.popularity_recommendations = pd.DataFrame(columns=df.columns)


    def recommend(self, user_id):
        print("Generating popularity recommendations...")
        return self.popularity_recommendations

# Ensure df is loaded from the CSV file
file_path = '/content/Hindi Songs.csv'

if os.path.exists(file_path):
    print(f"‚úÖ '{file_path}' found. Attempting to load...")
    try:
        df = pd.read_csv(file_path)
        print("‚úÖ Successfully loaded 'Hindi Songs.csv'.")

        # Initialize the Recommenders class
        pr = Recommenders()

        # Create the popularity recommender model
        pr.create(df, 'song_name', 'singer')

        # Get popularity recommendations
        popularity_recommendations = pr.recommend('user_example')

        # Display the recommendations
        print("\nTop 10 Popularity Recommendations:")
        if not popularity_recommendations.empty and 'song_name' in popularity_recommendations.columns and 'singer' in popularity_recommendations.columns and 'Stream' in popularity_recommendations.columns:
            print(popularity_recommendations[['song_name', 'singer', 'Stream']])
        else:
            print("No popularity recommendations to display (DataFrame is empty or missing columns). ")

    except Exception as e:
        print(f"‚ùå Error loading '{file_path}': {e}")
else:
    print(f"‚ùå Error: The file '{file_path}' was not found. Please ensure it is uploaded or available in the specified path.")